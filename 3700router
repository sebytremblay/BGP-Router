#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from pprint import pprint
from functools import cmp_to_key
import copy

class Router:

    relations = {}
    sockets = {}
    ports = {}
    
    updates = []
    forwarding_table = {}

    def __init__(self, asn, connections):
        """Initializes the router with its ASN and connections to other routers.

        Args:
            asn (int): The AS number of the router.
            connections (list): A list of strings, each of which represents a connection to another router. 
            Each string is in the format "port-neighbor-relation", where "port" is the port number on which 
            the router should listen for messages from "neighbor", and "relation" is the relationship between 
            the routers (either "peer" or "provider").
        """
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            print(f"Connected to {neighbor} on port {port} with relation {relation}")
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        """Returns the IP address of the router on the interface leading to the specified destination.

        Args:
            dst (str): The name of the destination router.

        Returns:
            str: The IP address of the router on the interface leading to the specified destination.
        """
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        if network not in self.sockets or network not in self.ports:
            print(f"Socket has netowrk: {network in self.sockets} and port has network: {network in self.ports}")
            print(f"Error: Trying to send message to unknown network {network}")
            return
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))
    
    def run(self):
        """Runs the router's main loop."""
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                
                self.handle_incoming_message(srcif, msg)

                # print("Received message '%s' from %s" % (msg, srcif))
    
    def handle_incoming_message(self, srcif, message, log=True):
        """Process incoming messages from neighbors.
        
        Args:
            srcif (str): The name of the interface on which the message was received.
            message (str): The message that was received."""
        # Attempt to parse the message as JSON
        try:
            json_message = json.loads(message)
        except Exception as e:
            print(f"Error parsing JSON message: {e}")
            return
        
        # Ensure the message contains a 'type' field
        if 'type' not in json_message:
            print("Error: Received message does not contain a 'type' field.")
            return

        # Determine the type of message and process it accordingly
        message_type = json_message['type']
        if message_type == 'update':
            self.process_route_update(srcif, json_message, log)
        elif message_type == 'withdraw':
            self.process_route_withdrawal(json_message)
        elif message_type == 'data':
            self.process_data(json_message, log)
        elif message_type == 'handshake':
            self.process_handshake(json_message['src'], json_message['dst'])
        elif message_type == 'dump':
            self.process_dump(json_message['src'], json_message['msg'])
        elif message_type == 'table' or message_type == 'no route':
            raise NotImplementedError()
        else:
            print(f"Unknown message type received: {message_type}")
            
    def process_handshake(self, src, dst):
        """Process handshake messages to establish connections with neighbors.
        
        Args:
            src (str): The source IP address of the handshake.
            dst (str): The destination IP address of the handshake.
        """
        # Acknowledge the handshake for logging or debugging purposes
        self.log_message(f"Handshake established with {src}.") 

    def process_route_update(self, srcif, message, log=True):
        """Update the forwarding table based on a received route update.

        Args:
            srcif (str): The interface on which the update was received.
            message (dict): The route update message.
        """
        # Do nothing is msg body does not have expect fields
        expected_fields = ['network', 'netmask', 'localpref', 'ASPath', 'origin', 'selfOrigin']
        for expected_field in expected_fields:
            if expected_field not in message['msg']:
                return
        
        # Extract the relevant fields from the message
        network = message['msg']['network']
        netmask = message['msg']['netmask']
        localpref = message['msg']['localpref']
        ASPath = message['msg']['ASPath']
        origin = message['msg']['origin']
        selfOrigin = message['msg']['selfOrigin']

        # Create a unique key for this route based on network and netmask
        # Use only network and netmask, map to a list of routes

        # # Check if this is a new route or an update to an existing route
        # if route_key in self.forwarding_table:
        #     # If it's an update, check if the new path is preferred based on your criteria
        #     # This is simplified; you'd typically compare AS path lengths, local pref, etc.
        #     existing_route = self.forwarding_table[route_key]
        #     message['msg']['next_hop'] = srcif
            
        #     if self.compare_routes(existing_route, message['msg']) == 1:
        #         self.forwarding_table[route_key] = {'origin': origin,
        #                                             'localpref': localpref,
        #                                             'network': network,
        #                                             'ASPath': ASPath,
        #                                             'netmask': netmask,
        #                                             'peer': srcif,
        #                                             'selfOrigin': selfOrigin,
        #                                             'next_hop': srcif}
        # else:
        #     # If it's a new route, add it directly
        #     self.forwarding_table[route_key] = {'origin': origin,
        #                                         'localpref': localpref,
        #                                         'network': network,
        #                                         'ASPath': ASPath,
        #                                         'netmask': netmask,
        #                                         'peer': srcif,
        #                                         'selfOrigin': selfOrigin,
        #                                         'next_hop': srcif}
            
        # Prepare the new route for the forwarding table
        new_packet = {'origin': origin,
                      'localpref': localpref,
                      'network': network,
                      'ASPath': ASPath,
                      'netmask': netmask,
                      'peer': srcif,
                      'selfOrigin': selfOrigin,
                      'next_hop': srcif}
        route_key = (network, netmask)
        
        # Add the new packet to the list of packets for the route_key
        if route_key in self.forwarding_table:
            self.forwarding_table[route_key].append(new_packet)
        else:
            self.forwarding_table[route_key] = [new_packet] 
            
        # If we have not seen this packet's relationhip, add it to the relations
        pprint(f"Current relations: {self.relations}")
        if network not in self.relations:
            self.sockets[network] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.relations[network] = self.relations[srcif]
            self.ports[network] = self.ports[srcif]
            pprint(f"Updated Relations: {self.relations}")
            
        # Propagate the update to neighbors based on BGP policies
        self.propagate_update(srcif, message)
        
        # Aggregate routes if necessary
        self.aggregate_routes()
        
        # Cache the update
        if log:
            self.updates.append(message)
            print(f"Updates after append in process_route_update(): {self.updates}")
    
    def propagate_update(self, srcif, message):
        """Propagates a route update to neighbors based on BGP policies.
        
        Args:
            srcif (str): The interface on which the update was received.
            message (dict): The route update message.
        """
        src_relationship = self.relations[srcif]

        # Prepare the message to be sent to neighbors, excluding private fields
        propagated_message = {
            'msg': {
                'netmask': message['msg']['netmask'],
                'ASPath': [self.asn] + message['msg']['ASPath'],
                'network': message['msg']['network']
            },
            'type': 'update',
        }

        # Determine which neighbors to send the update to
        for neighbor, relation in self.relations.items():
            if neighbor != srcif:  # Do not send the update back to the source
                # Update neighbor specific messaging
                propagated_message['src'] = self.our_addr(neighbor)
                propagated_message['dst'] = neighbor
                
                # Rule 1: If update received from a customer, send to all other neighbors
                if src_relationship == 'cust':
                    self.send(neighbor, json.dumps(propagated_message))
                    
                # Rule 2: If update received from a peer or provider, only send to customers
                elif src_relationship in ['peer', 'provider'] and relation == 'cust':
                    self.send(neighbor, json.dumps(propagated_message))
                
                # Otherwise log that we could not forward anywhere
                else:
                    print("Did not send anywhere.")
    
    def process_route_withdrawal(self, packet):
        """Remove a route from the forwarding table.
        
        Args:
            src: The source of the withdrawal.
            dst: The destination network of the route being withdrawn.
        """
        for revocation in packet['msg']:
            # If revocation is improperly formatted, ignore
            expected_fields = ['network', 'netmask']
            for expected_field in expected_fields:
                if expected_field not in revocation:
                    continue
            
            # Extract relevant fields
            network = revocation['network']
            netmask = revocation['netmask']

            # Delete all entries in forward table with these attributes
            delete_candidates = self.forwarding_table[(network, netmask)]
            routes_to_delete = []
            
            pprint(f"Delete candidates: {delete_candidates}")
            pprint(f"Table before withdraw: {self.forwarding_table}")
            
            for candidate in delete_candidates:
                if candidate['peer'] == packet['src']:
                    routes_to_delete.append(candidate)
                 
            # Process the route removal for each route
            pprint(f"Routes to delete: {routes_to_delete}")
            pprint(f"Table before withdraw: {self.forwarding_table}")
            
            # Remove the route from the forwarding table
            self.forwarding_table[(network, netmask)] = [route for route in delete_candidates if route not in routes_to_delete]
            
            # Remove any cached updates to this route
            self.remove_corresponding_updates(network, netmask, packet['src'])
                        
        # print(f"Updates after finish: {self.updates}")
        
        # Rebuild the table
        prev_table = self.forwarding_table.copy()
        # self.rebuild_table(packet['src'])
        print("="*80)
        pprint(f"Previous Table: {prev_table}")
        pprint(f"New Table: {self.forwarding_table}")
        print("="*80)
        # assert prev_table == self.forwarding_table, "Tables are not the same"
                        
        # Inform our neighbors of the withdrawal
        self.propagate_withdrawl(packet['src'], packet['msg'])
       
    def remove_corresponding_updates(self, network, netmask, src):
        """Removes all updates from the cache that correspond to a given route.

        Args:
            network (str): The network of the route.
            netmask (str): The netmask of the route.
        """
        # Removes all updates from the cache that correspond to a given route
        for update in self.updates:
            # If update is improperly formatted, ignore
            if 'network' in update['msg'] and 'netmask' in update['msg']:
                # Remove the update if it corresponds to the route
                if update['msg']['network'] == network and update['msg']['netmask'] == netmask and update['src'] == src:
                    pprint(f"Removing update: {update}")
                    self.updates.remove(update)
            
    def propagate_withdrawl(self, srcif, revocation_list):     
        src_relationship = self.relations[srcif]

        # Prepare the message to be sent to neighbors, excluding private fields
        propagated_message = {
            'type': 'withdraw',
            'msg': revocation_list
        }

        # Determine which neighbors to send the update to
        for neighbor, relation in self.relations.items():
            if neighbor != srcif:  # Do not send the update back to the source
                # Update neighbor specific messaging
                propagated_message['src'] = self.our_addr(neighbor)
                propagated_message['dst'] = neighbor
                
                # Rule 1: If update received from a customer, send to all other neighbors
                if src_relationship == 'cust':
                    self.send(neighbor, json.dumps(propagated_message))
                    
                # Rule 2: If update received from a peer or provider, only send to customers
                elif src_relationship in ['peer', 'provider'] and relation == 'cust':
                    self.send(neighbor, json.dumps(propagated_message))
                
                # Otherwise log that we could not forward anywhere
                else:
                    print("Did not send anywhere.") 
    
    def rebuild_table(self, srcif):
        """Deletes and rebuilds our forwarding table.
        
        Args:
            srcif (str): The interface on which the update was received."""
        self.forwarding_table = {}
        prev_updates = self.updates.copy()
        self.updates = []
        
        for update in prev_updates:
            self.handle_incoming_message(srcif, json.dumps(update), False)
    
    def process_data(self, message, log=True):
        """Process a data packet received from a neighbor.

        Args:
            message (dict): The message received from the neighbor.
        """
        # Logs data packet
        if log:
            self.updates.append(message)
            
        # Extracts information
        src = message['src']
        dst = message['dst']
        payload = message['msg']
        
        # If we have not seen this packet's relationhip, add it to the relations
        # pprint(f"Current relations: {self.relations}")
        # if dst not in self.relations:
        #     print(f"Default Src: {src}")
        #     print(f"Modified Src: {self.our_addr(src)}")
            
        #     self.relations[dst] = self.relations[self.our_addr(src)]
        #     pprint(f"Updated relations: {self.relations}")
                # Find all existing relations that this destination is in the same network of
        
        # Attempt to find a route for the destination
        routes_found = []
        for network, netmask in self.forwarding_table.keys():
            if self.ip_in_network(dst, network, netmask):
                for route in self.forwarding_table[(network, netmask)]:
                    self.relations[dst] = self.relations[network]
                    self.sockets[dst] = self.sockets[network]
                    self.ports[dst] = self.ports[network]
                    routes_found.append(route)
        
        # If no route is found, send a "no route" message back to the source
        if len(routes_found) == 0:
            self.send_no_route_message(src, dst)
        
        # If only one route is found, forward the packet to the next hop
        pprint(f"Relationships: {self.relations}")
        if len(routes_found) >= 1:
            best_route =  self.find_best_route(routes_found)
            next_hop = best_route['next_hop']
            dst_relationship = self.relations[next_hop]
            src_relationship = self.relations.get(src, '')
            
            if self.is_transaction_profitable(dst_relationship, src_relationship):
                self.send(next_hop,
                          json.dumps({'type': 'data', 
                                    'src': src, 
                                    'dst': dst, 
                                    'payload': payload}))
            else:
                # Inform source that the transaction was not profitable
                pprint(f"{src} Source Relationship Exists: {src in self.relations}")
                print(f"Did not send data to {next_hop} because it is not a profitable transaction.")
                self.send_no_route_message(src, dst)
            
    def is_transaction_profitable(self, dst_relation, src_relation):
        """Evaluates the protocol rules to determine if a message should be sent to a neighbor,
        assuming that an entry was found in the forwarding table.
        
        Args:
            dst_relation (str): The relationship of the destination neighbor.
            src_relation (str): The relationship of the source neighbor.
            
        Returns:
            bool: True if the transaction is profitable, False otherwise.
        """
        # If we received from a customer, send to all
        if src_relation == 'cust' or dst_relation == 'cust':
            return True
        
        # If we received from a peer or provider, only send to customers
        if (src_relation in ['peer', 'provider'] and dst_relation == 'cust') \
            or (dst_relation in ['peer', 'provider'] and src_relation == 'cust'):
            return True
        
        # Otherwise return false
        return False
    
    def ip_in_network(self, ip, network, netmask):
        """Check if an IP address is within a given network.

        Args:
            ip (str): The IP address to check.
            network (str): The network address.
            netmask (str): The network mask.

        Returns:
            bool: True if ip is within the network defined by network and netmask, False otherwise.
        """
        # Convert IP, network, and netmask to integers for comparison
        ip_int = self.ip_to_int(ip)
        network_int = self.ip_to_int(network)
        netmask_int = self.ip_to_int(netmask)
        
        return ip_int & netmask_int == network_int & netmask_int

    def send_no_route_message(self, src, dst):
        """Send a 'no route' message back to the source.

        Args:
            src (str): The source router IP or identifier from which the original message came.
            dst (str): The original destination IP that could not be routed.
        """
        # Construct the no route message
        no_route_message = json.dumps({
            'type': 'no route',
            'src': self.our_addr(src),
            'dst': dst,
            'msg': f"No route to {dst}"
        })
        
        # Send the message back to the source
        print("Sending no route message.")
        self.send(self.our_addr(src), no_route_message)
        
    def compare_routes(self, route1, route2):
        """Compare two routes based on specified criteria.
        
        Returns -1 if route1 is preferred, 1 if route2 is preferred, or 0 if they are equal.
        """
        # Choose the longest prefix match
        if self.netmask_to_prefix_length(route1['netmask']) != self.netmask_to_prefix_length(route2['netmask']):
            return -1 if self.netmask_to_prefix_length(route1['netmask']) \
                > self.netmask_to_prefix_length(route2['netmask']) else 1
        
        # Compare by localpref
        if route1['localpref'] != route2['localpref']:
            return -1 if route1['localpref'] > route2['localpref'] else 1
        
        # Compare by selfOrigin
        if route1['selfOrigin'] != route2['selfOrigin']:
            return -1 if route1['selfOrigin'] else 1
        
        # Compare by ASPath length
        if len(route1['ASPath']) != len(route2['ASPath']):
            return -1 if len(route1['ASPath']) < len(route2['ASPath']) else 1
        
        # Compare by origin
        origin_order = {'IGP': 0, 'EGP': 1, 'UNK': 2}
        if origin_order[route1['origin']] != origin_order[route2['origin']]:
            return -1 if origin_order[route1['origin']] < origin_order[route2['origin']] else 1
        
        # Compare by neighbor IP
        route1_ip = int.from_bytes(socket.inet_aton(route1['next_hop']), 'big')
        route2_ip = int.from_bytes(socket.inet_aton(route2['next_hop']), 'big')
        return -1 if route1_ip < route2_ip else 1 if route1_ip > route2_ip else 0
    
    def netmask_to_prefix_length(self, netmask):
        """
        Convert a netmask to its corresponding prefix length.

        Args:
            netmask (str): The netmask in dotted decimal notation (e.g., "255.255.255.0").

        Returns:
            int: The prefix length (number of leading 1 bits in the netmask).
        """
        # Convert the netmask from dotted decimal notation to a binary string
        netmask_bin = ''.join(format(int(octet), '08b') for octet in netmask.split('.'))
        # Count the number of leading 1s in the binary representation
        prefix_length = netmask_bin.count('1')
        
        return prefix_length
        
    def find_best_route(self, routes):
        """Find the best route based on the comparison function."""
        # Sort routes based on the comparison function
        sorted_routes = sorted(routes, key=cmp_to_key(self.compare_routes))
        # Return the best route
        return sorted_routes[0]
    
    def send_to_route(self, port_num, payload):
        """Send a data packet to the specified route in the forwarding table.

        Args:
            port_num (_type_): _description_
            payload (_type_): _description_
        """
        # Find the corresponding network in the forwarding table
        found_neighbor = ''
        for neighbor, port in self.ports.items():
            if port == port_num:
                found_neighbor = neighbor
                break
        
        # Send the message the netwrok
        self.send(found_neighbor, payload)
    
    def process_dump(self, src, table):
        """Process a dump of the neighbor's forwarding table.

        Args:
            src (str): The source of the dump.
            table (dict): The forwarding table of the neighbor."""
        # Aggregate the routes in the forwarding table
        self.aggregate_routes()
        
        # Convert the forwarding table to a list of routes
        table = []
        for route_list in self.forwarding_table.values():
            for route in route_list:
                table.append(route)
        
        for route in table:
            # Convert the network and netmask to strings for serialization
            route['peer'] = route.pop('next_hop')
            
        # Create a new "table" message with the aggregated routes
        table_message = {
            'src': self.our_addr(src),
            'dst': src,
            'type': 'table',
            'msg': table
        }
        self.send(src, json.dumps(table_message))

    def ip_to_int(self, ip):
        """Converts an IP address from string format to an integer.
        
        Args:
            ip (str): The IP address to convert.
            
        Returns:
            int: The integer representation of the IP address."""
        return sum(int(byte) << (8 * idx) for idx, byte in enumerate(reversed(ip.split('.'))))

    def int_to_ip(self, integer):
        """Converts an integer back to an IP address string.
        
        Args:
            integer (int): The integer to convert.
            
        Returns:
            str: The string representation of the IP address."""
        return '.'.join(str((integer >> (8 * i)) & 0xFF) for i in reversed(range(4)))
    
    def aggregate_routes(self):
        """
        Aggregate numerically adjacent routes in the forwarding table that have the same next-hop
        and identical attributes. This method sorts the routes by their network address, checks for adjacency,
        and aggregates routes where applicable. It repeats the process if any routes were aggregated to ensure
        all possible aggregations are completed.
        """
        return
        # Convert forwarding table to a list of (route_key, route_details) for easier manipulation
        routes_list = sorted(self.forwarding_table.items(), key=lambda item: self.ip_to_int(item[1]['network']))

        # Use index to iterate so we can modify the list while iterating
        i = 0
        while i < len(routes_list) - 1:
            current_route_key, current_route = routes_list[i]
            next_route_key, next_route = routes_list[i + 1]

            # Check if current and next routes are adjacent and have the same attributes
            if self.are_adjacent(current_route, next_route) and self.have_same_attributes(current_route, next_route):
                # Perform aggregation
                aggregated_route = self.aggregate(current_route, next_route)
                print(f"Aggregated {current_route} and {next_route} into {aggregated_route}")
                aggregated_route_key = f"{aggregated_route['network']}/{aggregated_route['netmask']}/{aggregated_route['ASPath'][-1]}"
                
                # Update forwarding table with the new aggregated route
                self.forwarding_table[aggregated_route_key] = aggregated_route

                # Remove the old routes from the forwarding table
                del self.forwarding_table[current_route_key]
                del self.forwarding_table[next_route_key]

                # Mark that aggregation has been performed
                aggregation_performed = True

                # Restart the process from the beginning to ensure all possible aggregations are checked
                break

            else:
                # Move to the next pair if no aggregation is possible
                i += 1

    def are_adjacent(self, route1, route2):
        """
        Determine if two routes are numerically adjacent.
        
        Args:
            route1 (dict): The first route, with 'network' and 'netmask' keys.
            route2 (dict): The second route, with 'network' and 'netmask' keys.
            
        Returns:
            bool: True if route1 and route2 are adjacent, False otherwise.
        """
        # Convert the network addresses and netmasks to integers
        network1 = self.ip_to_int(route1['network'])
        netmask1 = self.ip_to_int(route1['netmask'])
        network2 = self.ip_to_int(route2['network'])
        netmask2 = self.ip_to_int(route2['netmask'])

        # Calculate the broadcast address of the first network
        broadcast1 = network1 | (~netmask1 & 0xFFFFFFFF)

        # The second network is adjacent if its network address is one more than the broadcast address of the first
        return network2 == broadcast1 + 1

    def have_same_attributes(self, route1, route2):
        """Check if two routes have the same attributes.
        
        Args:
            route1 (dict): The first route to compare.
            route2 (dict): The second route to compare.
            
        Returns:
            bool: Whether the routes have the same attributes."""
        return route1['localpref'] == route2['localpref'] \
            and route1['origin'] == route2['origin'] \
            and route1['ASPath'] == route2['ASPath'] \
            and route1['selfOrigin'] == route2['selfOrigin'] \

    def aggregate(self, route1, route2):
        """
        Aggregate two adjacent routes into one. Assumes that the routes are adjacent
        and have the same netmask, next-hop, and other relevant attributes.

        Args:
            route1 (dict): The first route to aggregate.
            route2 (dict): The second route to aggregate.

        Returns:
            dict: A new route that represents the aggregation of route1 and route2.
        """
        # Convert netmask to integer for comparison and calculation
        netmask_int = self.ip_to_int(route1['netmask'])
        
        # Calculate the new netmask by subtracting one from the binary representation's length
        new_netmask_int = (netmask_int << 1) & 0xFFFFFFFF
        new_netmask = self.int_to_ip(new_netmask_int)
        
        # The new network is the lower of the two original networks under the new netmask
        new_network_int = self.ip_to_int(route1['network']) & new_netmask_int
        new_network = self.int_to_ip(new_network_int)

        # Return a new route with the aggregated network and netmask, and the same attributes
        return {
            'origin': route1['origin'],
            'localpref': route1['localpref'],
            'network': new_network,
            'ASPath': route1['ASPath'],
            'netmask': new_netmask,
            'peer': route1['peer'],
            'selfOrigin': route1['selfOrigin'],
        }

    def log_message(self, message):
        """
        Helper method for logging messages.
        """
        print(message)

    def shutdown(self):
        """
        Cleanly shut down the router, closing any open connections.
        """
        pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()