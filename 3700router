#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from pprint import pprint
from functools import cmp_to_key
# import sort
import copy

class Router:

    relations = {}
    sockets = {}
    ports = {}
    
    updates = []
    forwarding_table = {}

    def __init__(self, asn, connections):
        """Initializes the router with its ASN and connections to other routers.

        Args:
            asn (int): The AS number of the router.
            connections (list): A list of strings, each of which represents a connection to another router. 
            Each string is in the format "port-neighbor-relation", where "port" is the port number on which 
            the router should listen for messages from "neighbor", and "relation" is the relationship between 
            the routers (either "peer" or "provider").
        """
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            
            print(f"Connected to {neighbor} on port {port} with relation {relation}")
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))
            
        self.default_ports = self.ports.copy()
        self.default_relations = self.relations.copy()
        self.default_sockets = self.sockets.copy()

    def our_addr(self, dst):
        """Returns the IP address of the router on the interface leading to the specified destination.

        Args:
            dst (str): The name of the destination router.

        Returns:
            str: The IP address of the router on the interface leading to the specified destination.
        """
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        if network not in self.sockets or network not in self.ports:
            # print(f"Socket has network: {network in self.sockets} and port has network: {network in self.ports}")
            # print(f"Error: Trying to send message to unknown network {network}")
            return
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))
    
    def run(self):
        """Runs the router's main loop."""
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                
                self.handle_incoming_message(srcif, msg)

                # print("Received message '%s' from %s" % (msg, srcif))
    
    def handle_incoming_message(self, srcif, message, log=True):
        """Process incoming messages from neighbors.
        
        Args:
            srcif (str): The name of the interface on which the message was received.
            message (str): The message that was received."""
        # Attempt to parse the message as JSON
        try:
            json_message = json.loads(message)
        except Exception as e:
            print(f"Error parsing JSON message: {e}")
            return
        
        # Ensure the message contains a 'type' field
        if 'type' not in json_message:
            print("Error: Received message does not contain a 'type' field.")
            return

        # Determine the type of message and process it accordingly
        message_type = json_message['type']
        if message_type == 'update':
            self.process_route_update(srcif, json_message, log)
        elif message_type == 'withdraw':
            self.process_route_withdrawal(json_message)
        elif message_type == 'data':
            self.process_data(json_message, log)
        elif message_type == 'handshake':
            self.process_handshake(json_message['src'], json_message['dst'])
        elif message_type == 'dump':
            self.process_dump(json_message['src'], json_message['msg'])
        elif message_type == 'table' or message_type == 'no route':
            raise NotImplementedError()
        else:
            print(f"Unknown message type received: {message_type}")
            
    def process_handshake(self, src, dst):
        """Process handshake messages to establish connections with neighbors.
        
        Args:
            src (str): The source IP address of the handshake.
            dst (str): The destination IP address of the handshake.
        """
        # Acknowledge the handshake for logging or debugging purposes
        self.log_message(f"Handshake established with {src}.") 

    def process_route_update(self, srcif, message, log=True):
        """Update the forwarding table based on a received route update.

        Args:
            srcif (str): The interface on which the update was received.
            message (dict): The route update message.
        """
        # Do nothing is msg body does not have expect fields
        expected_fields = ['network', 'netmask', 'localpref', 'ASPath', 'origin', 'selfOrigin']
        for expected_field in expected_fields:
            if expected_field not in message['msg']:
                return
        
        # Extract the relevant fields from the message
        network = message['msg']['network']
        netmask = message['msg']['netmask']
        localpref = message['msg']['localpref']
        ASPath = message['msg']['ASPath']
        origin = message['msg']['origin']
        selfOrigin = message['msg']['selfOrigin']
            
        # Prepare the new route for the forwarding table
        new_packet = {'origin': origin,
                      'localpref': localpref,
                      'network': network,
                      'ASPath': ASPath,
                      'netmask': netmask,
                      'peer': srcif,
                      'selfOrigin': selfOrigin,
                      'next_hop': srcif}
        route_key = (network, netmask)
        
        # Add the new packet to the list of packets for the route_key
        if route_key in self.forwarding_table:
            self.forwarding_table[route_key].append(new_packet)
        else:
            self.forwarding_table[route_key] = [new_packet] 
            
        # If we have not seen this packet's relationhip, add it to the relations
        # pprint(f"Current relations: {self.relations}")
        # if network not in self.relations:
        #     self.sockets[network] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        #     self.relations[network] = self.relations[srcif]
        #     self.ports[network] = self.ports[srcif]
        #     pprint(f"Updated Relations: {self.relations}")
        
        # pprint(f"Current Relations: {self.relations}")
        # Find similar relations if they already exists
        for relation in self.relations:
            if self.ip_in_network(relation, network, netmask):
                # print(f"Found similar relation: {relation}")
                # self.sockets[network] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                # self.sockets[network].bind(('localhost', 0))
                
                self.relations[network] = self.relations[relation]
                self.ports[network] = self.ports[relation]
                break
                
        # Otherwise create new entry
        if network not in self.relations:
            self.relations[network] = self.relations[srcif]
            self.ports[network] = self.ports[srcif]
            
            # self.sockets[network] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            # self.sockets[network].bind(('localhost', 0))
            
        # Propagate the update to neighbors based on BGP policies
        self.propagate_update(srcif, message)
        
        # Aggregate routes if necessary
        self.aggregate_routes()
        
        # Cache the update
        if log:
            self.updates.append((srcif, message))
            print(f"Updates after append in process_route_update(): {self.updates}")
    
    def propagate_update(self, srcif, message):
        """Propagates a route update to neighbors based on BGP policies.
        
        Args:
            srcif (str): The interface on which the update was received.
            message (dict): The route update message.
        """
        src_relationship = self.relations[srcif]

        # Prepare the message to be sent to neighbors, excluding private fields
        propagated_message = {
            'msg': {
                'netmask': message['msg']['netmask'],
                'ASPath': [self.asn] + message['msg']['ASPath'],
                'network': message['msg']['network']
            },
            'type': 'update',
        }

        # Determine which neighbors to send the update to
        for neighbor, relation in self.relations.items():
            if neighbor != srcif:  # Do not send the update back to the source
                # Update neighbor specific messaging
                propagated_message['src'] = self.our_addr(neighbor)
                propagated_message['dst'] = neighbor
                
                # Send the update to the neighbor if needed
                if self.is_transaction_profitable(relation, self.relations[srcif]):
                    self.send(neighbor, json.dumps(propagated_message))
                else:
                    print(f"Transaction not profitable: {relation} -> {self.relations[srcif]}")
    
    def process_route_withdrawal(self, packet):
        """Remove a route from the forwarding table.
        
        Args:
            src: The source of the withdrawal.
            dst: The destination network of the route being withdrawn.
        """
        for revocation in packet['msg']:
            # If revocation is improperly formatted, ignore
            expected_fields = ['network', 'netmask']
            for expected_field in expected_fields:
                if expected_field not in revocation:
                    continue
            
            # Extract relevant fields
            network = revocation['network']
            netmask = revocation['netmask']

            # Delete all entries in forward table with these attributes
            delete_candidates = self.forwarding_table.get((network, netmask), [])
            routes_to_delete = []
            
            # pprint(f"Delete candidates: {delete_candidates}")
            # pprint(f"Table before withdraw: {self.forwarding_table}")
            
            for candidate in delete_candidates:
                if candidate['peer'] == packet['src']:
                    routes_to_delete.append(candidate)
                 
            # Process the route removal for each route
            # pprint(f"Routes to delete: {routes_to_delete}")
            # pprint(f"Table before withdraw: {self.forwarding_table}")
            
            # Remove the route from the forwarding table
            self.forwarding_table[(network, netmask)] = [route for route in delete_candidates if route not in routes_to_delete]
            
            # Remove any cached updates to this route
            self.remove_corresponding_updates(network, netmask, packet['src'])
                        
        # print(f"Updates after finish: {self.updates}")
        
        # Rebuild the table
        prev_table = self.forwarding_table.copy()
        # self.rebuild_table()
        print("="*80)
        pprint(f"Previous Table: {prev_table}")
        pprint(f"New Table: {self.forwarding_table}")
        print("="*80)
        # # assert prev_table == self.forwarding_table, "Tables are not the same"
                        
        # Inform our neighbors of the withdrawal
        self.propagate_withdrawl(packet['src'], packet['msg'])
       
    def remove_corresponding_updates(self, network, netmask, src):
        """Removes all updates from the cache that correspond to a given route.

        Args:
            network (str): The network of the route.
            netmask (str): The netmask of the route.
        """
        # Removes all updates from the cache that correspond to a given route
        prev_updates = self.updates.copy()
        
        for update_pair in self.updates:
            srcif = update_pair[0]
            update = update_pair[1]
            
            # If update is improperly formatted, ignore
            if 'network' in update['msg'] and 'netmask' in update['msg']:
                # Remove the update if it corresponds to the route
                if update['msg']['network'] == network and update['msg']['netmask'] == netmask and srcif == src:
                    # pprint(f"Removing update: {update}")
                    self.updates.remove((srcif, update))
                    
        # pprint(f"Previous updates: {prev_updates} with length: {len(prev_updates)}")
        # pprint(f"Current updates: {self.updates} with length: {len(self.updates)}")
            
    def propagate_withdrawl(self, srcif, revocation_list):     
        # Prepare the message to be sent to neighbors, excluding private fields
        propagated_message = {
            'type': 'withdraw',
            'msg': revocation_list
        }

        # Determine which neighbors to send the update to
        for neighbor, relation in self.relations.items():
            if neighbor != srcif:  # Do not send the update back to the source
                # Update neighbor specific messaging
                propagated_message['src'] = self.our_addr(neighbor)
                propagated_message['dst'] = neighbor
                
                # Send the update to the neighbor if needed
                if self.is_transaction_profitable(relation, self.relations[srcif]):
                    self.send(neighbor, json.dumps(propagated_message))
                else:
                    print(f"Transaction not profitable: {relation} -> {self.relations[srcif]}")
    
    def rebuild_table(self):
        """Deletes and rebuilds our forwarding table.
        
        Args:
            srcif (str): The interface on which the update was received."""
        self.forwarding_table = {}
        prev_updates = self.updates.copy()
        self.updates = []
        
        # pprint(f"Rebuilding table from updates: {prev_updates}")
        self.relations = self.default_relations.copy()
        self.ports = self.default_ports.copy()
        self.sockets = self.default_sockets.copy()
        
        for update_pair in prev_updates:
            srcif = update_pair[0]
            update = update_pair[1]
            self.handle_incoming_message(srcif, json.dumps(update), True)
    
    def process_data(self, message, log=True):
        """Process a data packet received from a neighbor.

        Args:
            message (dict): The message received from the neighbor.
        """            
        # Extracts information
        src = message['src']
        dst = message['dst']
        payload = message['msg']
        
        # Logs data packet
        if log:
            self.updates.append((src, message))
        
        # Attempt to find a route for the destination
        routes_found = []
        # pprint(f"Forwarding Table: {self.forwarding_table}")
        for network, netmask in self.forwarding_table.keys():
            if self.ip_in_network(dst, network, netmask):
                for route in self.forwarding_table[(network, netmask)]:
                    self.relations[dst] = self.relations[network]
                    # self.sockets[dst] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    self.ports[dst] = self.ports[network]
                    routes_found.append(route)
        
        # If no route is found, send a "no route" message back to the source
        if len(routes_found) == 0:
            self.send_no_route_message(src, dst)
        
        # If only one route is found, forward the packet to the next hop
        # pprint(f"Relationships: {self.relations}")
        # pprint(f"Routes Found: {routes_found}")
        if len(routes_found) >= 1:
            best_route =  self.find_best_route(routes_found)
            # pprint(f"Best Route: {best_route}")
            next_hop = best_route['next_hop']
            dst_relationship = self.relations[next_hop]
            src_relationship = self.relations.get(src, '')
            
            if self.is_transaction_profitable(dst_relationship, src_relationship):
                self.send(next_hop,
                          json.dumps({'type': 'data', 
                                    'src': src, 
                                    'dst': dst, 
                                    'payload': payload}))
            else:
                # Inform source that the transaction was not profitable
                # pprint(f"{src} Source Relationship Exists: {src in self.relations}")
                print(f"Did not send data to {next_hop} because it is not a profitable transaction.")
                self.send_no_route_message(src, dst)
            
    def is_transaction_profitable(self, dst_relation, src_relation):
        """Evaluates the protocol rules to determine if a message should be sent to a neighbor,
        assuming that an entry was found in the forwarding table.
        
        Args:
            dst_relation (str): The relationship of the destination neighbor.
            src_relation (str): The relationship of the source neighbor.
            
        Returns:
            bool: True if the transaction is profitable, False otherwise.
        """
        # If we received from a customer, send to all
        if src_relation == 'cust' or dst_relation == 'cust':
            return True
        
        # If we received from a peer or provider, only send to customers
        if (src_relation in ['peer', 'provider'] and dst_relation == 'cust') \
            or (dst_relation in ['peer', 'provider'] and src_relation == 'cust'):
            return True
        
        # Otherwise return false
        return False
    
    def ip_in_network(self, ip, network, netmask):
        """Check if an IP address is within a given network.

        Args:
            ip (str): The IP address to check.
            network (str): The network address.
            netmask (str): The network mask.

        Returns:
            bool: True if ip is within the network defined by network and netmask, False otherwise.
        """
        # Convert IP, network, and netmask to integers for comparison
        ip_int = self.ip_to_int(ip)
        network_int = self.ip_to_int(network)
        netmask_int = self.ip_to_int(netmask)
        
        return ip_int & netmask_int == network_int & netmask_int

    def send_no_route_message(self, src, dst):
        """Send a 'no route' message back to the source.

        Args:
            src (str): The source router IP or identifier from which the original message came.
            dst (str): The original destination IP that could not be routed.
        """
        # Construct the no route message
        no_route_message = json.dumps({
            'type': 'no route',
            'src': self.our_addr(src),
            'dst': dst,
            'msg': f"No route to {dst}"
        })
        
        # Send the message back to the source
        print("Sending no route message.")
        self.send(self.our_addr(src), no_route_message)
        
    def compare_routes(self, route1, route2):
        """Compare two routes based on specified criteria.
        
        Returns -1 if route1 is preferred, 1 if route2 is preferred, or 0 if they are equal.
        """
        # Choose the longest prefix match
        if self.netmask_to_prefix_length(route1['netmask']) != self.netmask_to_prefix_length(route2['netmask']):
            return -1 if self.netmask_to_prefix_length(route1['netmask']) \
                > self.netmask_to_prefix_length(route2['netmask']) else 1
        
        # Compare by localpref
        if route1['localpref'] != route2['localpref']:
            return -1 if route1['localpref'] > route2['localpref'] else 1
        
        # Compare by selfOrigin
        if route1['selfOrigin'] != route2['selfOrigin']:
            return -1 if route1['selfOrigin'] else 1
        
        # Compare by ASPath length
        if len(route1['ASPath']) != len(route2['ASPath']):
            return -1 if len(route1['ASPath']) < len(route2['ASPath']) else 1
        
        # Compare by origin
        origin_order = {'IGP': 0, 'EGP': 1, 'UNK': 2}
        if origin_order[route1['origin']] != origin_order[route2['origin']]:
            return -1 if origin_order[route1['origin']] < origin_order[route2['origin']] else 1
        
        # Compare by neighbor IP
        route1_ip = int.from_bytes(socket.inet_aton(route1['next_hop']), 'big')
        route2_ip = int.from_bytes(socket.inet_aton(route2['next_hop']), 'big')
        return -1 if route1_ip < route2_ip else 1 if route1_ip > route2_ip else 0
    
    def netmask_to_prefix_length(self, netmask):
        """
        Convert a netmask to its corresponding prefix length.

        Args:
            netmask (str): The netmask in dotted decimal notation (e.g., "255.255.255.0").

        Returns:
            int: The prefix length (number of leading 1 bits in the netmask).
        """
        # Convert the netmask to an integer
        netmask_int = self.ip_to_int(netmask)
        
        # Count the number of leading 1 bits
        prefix_length = 0
        while netmask_int & (1 << (31 - prefix_length)):
            prefix_length += 1
        
        return prefix_length
        
    def find_best_route(self, routes):
        """Find the best route based on the comparison function."""
        # Sort routes based on the comparison function
        sorted_routes = sorted(routes, key=cmp_to_key(self.compare_routes))
        # Return the best route
        return sorted_routes[0]
    
    def process_dump(self, src, table):
        """Process a dump of the neighbor's forwarding table.

        Args:
            src (str): The source of the dump.
            table (dict): The forwarding table of the neighbor."""
        # Aggregate the routes in the forwarding table
        self.aggregate_routes()
        
        # Convert the forwarding table to a list of routes
        table = []
        for route_list in self.forwarding_table.values():
            for route in route_list:
                table.append(route.copy())
        
        for route in table:
            # Convert the network and netmask to strings for serialization
            route['peer'] = route.pop('next_hop')
            
        # Create a new "table" message with the aggregated routes
        table_message = {
            'src': self.our_addr(src),
            'dst': src,
            'type': 'table',
            'msg': table
        }
        self.send(src, json.dumps(table_message))

    def ip_to_int(self, ip):
        """Converts an IP address from string format to an integer.
        
        Args:
            ip (str): The IP address to convert.
            
        Returns:
            int: The integer representation of the IP address."""
        return sum(int(byte) << (8 * idx) for idx, byte in enumerate(reversed(ip.split('.'))))

    def int_to_ip(self, integer):
        """Converts an integer back to an IP address string.
        
        Args:
            integer (int): The integer to convert.
            
        Returns:
            str: The string representation of the IP address."""
        return '.'.join(str((integer >> (8 * i)) & 0xFF) for i in reversed(range(4)))
    
    def cidr_to_netmask(self, prefix_length):
        """Converts a CIDR prefix length to a netmask."""
        return self.int_to_ip((0xffffffff >> (32 - prefix_length)) << (32 - prefix_length))

    def netmask_to_cidr(self, netmask):
        """Converts a netmask to its CIDR prefix length."""
        return bin(self.ip_to_int(netmask)).count('1')

    def aggregate(self, route1, route2):
        """Aggregate two adjacent routes into one with a broader netmask."""
        prefix_length = self.netmask_to_cidr(route1['netmask'])
        new_prefix_length = prefix_length - 1
        new_netmask = self.cidr_to_netmask(new_prefix_length)
        new_network_int = self.ip_to_int(route1['network']) & self.ip_to_int(new_netmask)
        new_network = self.int_to_ip(new_network_int)
        
        pprint(f"Aggregated {route1['network']}/{route1['netmask']} and {route2['network']}{route2['netmask']} into {new_network}/{new_netmask}")

        return new_network, new_netmask
    
    def are_adjacent(self, route1, route2):
        """Check if two networks are adjacent and suitable for aggregation."""
        network1 = self.ip_to_int(route1['network'])
        network2 = self.ip_to_int(route2['network'])
        netmask1 = self.ip_to_int(route1['netmask'])

        # Calculate the size of the network from the netmask
        network_size = 1 << (32 - self.netmask_to_cidr(route1['netmask']))

        # Check if the networks are adjacent by their numerical difference
        return abs(network2 - network1) == network_size

    def can_aggregate(self, route1, route2):
        """Check if two routes can be aggregated."""
        if not self.have_same_attributes(route1, route2):
            return False

        # Ensure both routes have the same netmask and are adjacent
        if route1['netmask'] != route2['netmask']:
            return False

        return self.are_adjacent(route1, route2)


    def have_same_attributes(self, route1, route2):
        """Check if two routes have the same attributes."""
        attributes_to_compare = ['localpref', 'origin', 'ASPath', 'peer', 'selfOrigin']
        return all(route1[attr] == route2[attr] for attr in attributes_to_compare)

    def aggregate_routes(self):
        """Aggregate routes based on CIDR notations."""
        all_routes = [route for routes in self.forwarding_table.values() for route in routes]
        all_routes.sort(key=lambda x: self.ip_to_int(x['network']))

        aggregated = True
        while aggregated:
            aggregated = False
            i = 0
            while i < len(all_routes) - 1:
                if self.can_aggregate(all_routes[i], all_routes[i + 1]):
                    new_network, new_netmask = self.aggregate(all_routes[i], all_routes[i + 1])
                    new_route = copy.deepcopy(all_routes[i])
                    new_route['network'] = new_network
                    new_route['netmask'] = new_netmask
                    all_routes[i:i + 2] = [new_route]  # Replace the two routes with the aggregated one
                    aggregated = True
                else:
                    i += 1

        # Update the forwarding table with aggregated routes
        self.forwarding_table.clear()
        for route in all_routes:
            key = (route['network'], route['netmask'])
            self.forwarding_table[key] = self.forwarding_table.get(key, []) + [route]

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()