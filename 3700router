#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from functools import cmp_to_key
import copy

class Router:

    relations = {}
    sockets = {}
    ports = {}
    
    updates = []
    forwarding_table = {}

    def __init__(self, asn, connections):
        """Initializes the router with its ASN and connections to other routers.

        Args:
            asn (int): The AS number of the router.
            connections (list): A list of strings, each of which represents a connection to another router. 
            Each string is in the format "port-neighbor-relation", where "port" is the port number on which 
            the router should listen for messages from "neighbor", and "relation" is the relationship between 
            the routers (either "peer" or "provider").
        """
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            print(f"Connected to {neighbor} on port {port} with relation {relation}")
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        """Returns the IP address of the router on the interface leading to the specified destination.

        Args:
            dst (str): The name of the destination router.

        Returns:
            str: The IP address of the router on the interface leading to the specified destination.
        """
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        """Sends a message to the specified network.
        
        Args:
            network (str): The name of the network to which the message should be sent.
            message (str): The message to send, which will be encoded as JSON.
        """
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        """Runs the router's main loop."""
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                
                self.handle_incoming_message(srcif, msg)

                # print("Received message '%s' from %s" % (msg, srcif))
    
    def handle_incoming_message(self, srcif, message):
        """Process incoming messages from neighbors.
        
        Args:
            srcif (str): The name of the interface on which the message was received.
            message (str): The message that was received."""
        # Attempt to parse the message as JSON
        try:
            json_message = json.loads(message)
        except Exception as e:
            print(f"Error parsing JSON message: {e}")
            return
        
        # Ensure the message contains a 'type' field
        if 'type' not in json_message:
            print("Error: Received message does not contain a 'type' field.")
            return

        # Determine the type of message and process it accordingly
        message_type = json_message['type']
        if message_type == 'update':
            self.process_route_update(srcif, json_message)
        elif message_type == 'withdraw':
            self.process_route_withdrawal(json_message['src'], json_message['dst'])
        elif message_type == 'data':
            self.process_data(json_message['src'], json_message['dst'], json_message['msg'])
        elif message_type == 'handshake':
            self.process_handshake(json_message['src'], json_message['dst'])
        elif message_type == 'dump':
            self.process_dump(json_message['src'], json_message['msg'])
        elif message_type == 'table' or message_type == 'no route':
            raise NotImplementedError()
        else:
            print(f"Unknown message type received: {message_type}")
            
    def process_handshake(self, src, dst):
        """Process handshake messages to establish connections with neighbors.
        
        Args:
            src (str): The source IP address of the handshake.
            dst (str): The destination IP address of the handshake.
        """
        # Acknowledge the handshake for logging or debugging purposes
        self.log_message(f"Handshake established with {src}.") 

    def process_route_update(self, srcif, message):
        """Update the forwarding table based on a received route update.

        Args:
            srcif (str): The interface on which the update was received.
            message (dict): The route update message.
        """
        # Extract the relevant fields from the message
        network = message['msg']['network']
        netmask = message['msg']['netmask']
        localpref = message['msg']['localpref']
        ASPath = message['msg']['ASPath']
        origin = message['msg']['origin']
        selfOrigin = message['msg']['selfOrigin']

        # Create a unique key for this route based on network and netmask
        route_key = f"{network}/{netmask}"

        # Check if this is a new route or an update to an existing route
        if route_key in self.forwarding_table:
            # If it's an update, check if the new path is preferred based on your criteria
            # This is simplified; you'd typically compare AS path lengths, local pref, etc.
            existing_route = self.forwarding_table[route_key]
            
            if self.compareRoutes(existing_route, message['msg']) == 1:
                self.forwarding_table[route_key] = {'network': network,
                                                    'netmask': netmask,
                                                    'localpref': localpref,
                                                    'ASPath': ASPath,
                                                    'origin': origin,
                                                    'selfOrigin': selfOrigin,
                                                    'next_hop': srcif}
        else:
            # If it's a new route, add it directly
            self.forwarding_table[route_key] = {'network': network,
                                                'netmask': netmask,
                                                'localpref': localpref,
                                                'ASPath': ASPath,
                                                'origin': origin,
                                                'selfOrigin': selfOrigin,
                                                'next_hop': srcif}
            
        # Propagate the update to neighbors based on BGP policies
        self.propagate_update(srcif, message)
    
    def propagate_update(self, srcif, message):
        """Propagates a route update to neighbors based on BGP policies.
        
        Args:
            srcif (str): The interface on which the update was received.
            message (dict): The route update message.
        """
        src_relationship = self.relations[srcif]

        # Prepare the message to be sent to neighbors, excluding private fields
        propagated_message = {
            'msg': {
                'netmask': message['msg']['netmask'],
                'ASPath': [self.asn] + message['msg']['ASPath'],
                'network': message['msg']['network']
            },
            'type': 'update',
        }

        # Determine which neighbors to send the update to
        for neighbor, relation in self.relations.items():
            if neighbor != srcif:  # Do not send the update back to the source
                # Update neighbor specific messaging
                propagated_message['src'] = self.our_addr(neighbor)
                propagated_message['dst'] = neighbor
                
                # Rule 1: If update received from a customer, send to all other neighbors
                if src_relationship == 'cust':
                    self.send(neighbor, json.dumps(propagated_message))
                    
                # Rule 2: If update received from a peer or provider, only send to customers
                elif src_relationship in ['peer', 'provider'] and relation == 'cust':
                    self.send(neighbor, json.dumps(propagated_message))
                
                # Otherwise log that we could not forward anywhere
                else:
                    print("Did not send anywhere.")
        
    def process_route_withdrawal(self, src, dst):
        """Remove a route from the forwarding table.
        
        Args:
            src: The source of the withdrawal.
            dst: The destination network of the route being withdrawn.
        """
        # Withdraw the route from the forwarding table
        if dst in self.forwarding_table:
            del self.forwarding_table[dst]
            
            # Drop the current forwarding table and request a new one from all neighbors
            self.log_message(f"Route to {dst} withdrawn.")
    
    def process_data(self, src, dst, payload):
        """Process a data packet received from a neighbor.

        Args:
            src (str): The source IP address of the data packet, indicating the neighbor router it came from.
            dst (str): The destination IP address of the data packet.
            payload (dict): The payload of the data packet.
        """
        # Attempt to find a route for the destination
        routes_found = []
        for route_key, route_details in self.forwarding_table.items():
            network, netmask = route_key.split('/')
            if self.ip_in_network(dst, network, netmask):
                routes_found.append(route_details)
        
        # If no route is found, send a "no route" message back to the source
        if len(routes_found) == 0:
            self.send_no_route_message(src, dst)
        
        # If only one route is found, forward the packet to the next hop
        if len(routes_found) == 1:
            next_hop = routes_found[0]['next_hop']
            self.send(next_hop, json.dumps({'type': 'data', 'src': src, 'dst': dst, 'payload': payload}))
        elif len(routes_found) > 1:
            best_route =  self.find_best_route(routes_found)
            self.send(best_route['next_hop'], 
                      json.dumps({'type': 'data', 
                                  'src': src, 
                                  'dst': dst, 
                                  'payload': payload}))

    def ip_in_network(self, ip, network, netmask):
        """Check if an IP address is within a given network.

        Args:
            ip (str): The IP address to check.
            network (str): The network address.
            netmask (str): The network mask.

        Returns:
            bool: True if ip is within the network defined by network and netmask, False otherwise.
        """
        # Convert IP, network, and netmask to integers for comparison
        ip_int = self.ip_to_int(ip)
        network_int = self.ip_to_int(network)
        netmask_int = self.ip_to_int(netmask)
        
        return ip_int & netmask_int == network_int & netmask_int

    def send_no_route_message(self, src, dst):
        """Send a 'no route' message back to the source.

        Args:
            src (str): The source router IP or identifier from which the original message came.
            dst (str): The original destination IP that could not be routed.
        """
        # Construct the no route message
        no_route_message = json.dumps({
            'type': 'no route',
            'src': self.asn,
            'dst': dst,
            'msg': f"No route to {dst}"
        })
        
        # Send the message back to the source
        self.send(src, no_route_message)
        
    def compareRoutes(self, route1, route2):
        """Compare two routes based on specified criteria.
        
        Returns -1 if route1 is preferred, 1 if route2 is preferred, or 0 if they are equal.
        """
        # Choose the longest prefix match
        if self.netmask_to_prefix_length(route1['netmask']) != self.netmask_to_prefix_length(route2['netmask']):
            return -1 if self.netmask_to_prefix_length(route1['netmask']) \
                > self.netmask_to_prefix_length(route2['netmask']) else 1
        
        # Compare by localpref
        if route1['localpref'] != route2['localpref']:
            return -1 if route1['localpref'] > route2['localpref'] else 1
        
        # Compare by selfOrigin
        if route1['selfOrigin'] != route2['selfOrigin']:
            return -1 if route1['selfOrigin'] else 1
        
        # Compare by ASPath length
        if len(route1['ASPath']) != len(route2['ASPath']):
            return -1 if len(route1['ASPath']) < len(route2['ASPath']) else 1
        
        # Compare by origin
        origin_order = {'IGP': 0, 'EGP': 1, 'UNK': 2}
        if origin_order[route1['origin']] != origin_order[route2['origin']]:
            return -1 if origin_order[route1['origin']] < origin_order[route2['origin']] else 1
        
        # Compare by neighbor IP
        route1_ip = int.from_bytes(socket.inet_aton(route1['next_hop']), 'big')
        route2_ip = int.from_bytes(socket.inet_aton(route2['next_hop']), 'big')
        return -1 if route1_ip < route2_ip else 1 if route1_ip > route2_ip else 0
    
    def netmask_to_prefix_length(self, netmask):
        """
        Convert a netmask to its corresponding prefix length.

        Args:
            netmask (str): The netmask in dotted decimal notation (e.g., "255.255.255.0").

        Returns:
            int: The prefix length (number of leading 1 bits in the netmask).
        """
        # Convert the netmask from dotted decimal notation to a binary string
        netmask_bin = ''.join(format(int(octet), '08b') for octet in netmask.split('.'))
        # Count the number of leading 1s in the binary representation
        prefix_length = netmask_bin.count('1')
        
        return prefix_length
        
    def find_best_route(self, routes):
        """Find the best route based on the comparison function."""
        # Sort routes based on the comparison function
        sorted_routes = sorted(routes, key=cmp_to_key(self.compareRoutes))
        # Return the best route
        return sorted_routes[0]
    
    def send_to_route(self, port_num, payload):
        """Send a data packet to the specified route in the forwarding table.

        Args:
            port_num (_type_): _description_
            payload (_type_): _description_
        """
        # Find the corresponding network in the forwarding table
        found_neighbor = ''
        for neighbor, port in self.ports.items():
            if port == port_num:
                found_neighbor = neighbor
                break
        
        # Send the message the netwrok
        self.send(found_neighbor, payload)
    
    def process_dump(self, src, table):
        """Process a dump of the neighbor's forwarding table.

        Args:
            src (str): The source of the dump.
            table (dict): The forwarding table of the neighbor."""
        # Aggregate the routes in the forwarding table
        self.aggregate_routes()
        # Convert the forwarding table to a list of routes
        table = list(self.forwarding_table.values())
        
        for route in table:
            # Convert the network and netmask to strings for serialization
            route['peer'] = route.pop('next_hop')
        # Create a new "table" message with the aggregated routes
        table_message = {
            'src': self.our_addr(src),
            'dst': src,
            'type': 'table',
            'msg': table
        }
        self.send(src, json.dumps(table_message))

    def announce_routes(self):
        """
        Announce routes to neighbors.
        """
        pass

    def withdraw_route(self, dest):
        """
        Withdraw a previously announced route.
        """
        pass

    def ip_to_int(self, ip):
        """Converts an IP address from string format to an integer.
        
        Args:
            ip (str): The IP address to convert.
            
        Returns:
            int: The integer representation of the IP address."""
        return sum(int(byte) << (8 * idx) for idx, byte in enumerate(reversed(ip.split('.'))))

    def int_to_ip(self, integer):
        """Converts an integer back to an IP address string.
        
        Args:
            integer (int): The integer to convert.
            
        Returns:
            str: The string representation of the IP address."""
        return '.'.join(str((integer >> (8 * i)) & 0xFF) for i in reversed(range(4)))

    def aggregate_routes(self):
        """Aggregate numerically adjacent routes in the forwarding table that have the same next-hop
        and identical attributes.
        """
        # Sort routes based on network address (converted to integer for comparison)
        routes = list(self.forwarding_table.values())
        routes.sort(key=lambda x: self.ip_to_int(x['network']))
        aggregated = False
        i = 0
        while i < len(self.forwarding_table) - 1:
            route1 = routes[i]
            route2 = routes[i + 1]
            
            # Check if routes are adjacent and have the same next-hop and attributes
            if self.are_adjacent(route1, route2) and self.have_same_attributes(route1, route2):
                # Aggregate routes
                new_route = self.aggregate(route1, route2)
                self.forwarding_table[i] = new_route
                routes[i] = new_route
                del self.forwarding_table[i + 1]
                del routes[i + 1]
                aggregated = True
            else:
                i += 1
        
        # If any routes were aggregated, repeat the process in case further aggregation is possible
        if aggregated:
            self.aggregate_routes()

    def are_adjacent(self, route1, route2):
        """
        Determine if two routes are numerically adjacent.
        
        Args:
            route1 (dict): The first route, with 'network' and 'netmask' keys.
            route2 (dict): The second route, with 'network' and 'netmask' keys.
            
        Returns:
            bool: True if route1 and route2 are adjacent, False otherwise.
        """
        # Convert the network addresses and netmasks to integers
        network1 = self.ip_to_int(route1['network'])
        netmask1 = self.ip_to_int(route1['netmask'])
        network2 = self.ip_to_int(route2['network'])
        netmask2 = self.ip_to_int(route2['netmask'])

        # Calculate the broadcast address of the first network
        broadcast1 = network1 | (~netmask1 & 0xFFFFFFFF)

        # The second network is adjacent if its network address is one more than the broadcast address of the first
        return network2 == broadcast1 + 1

    def have_same_attributes(self, route1, route2):
        """Check if two routes have the same attributes.
        
        Args:
            route1 (dict): The first route to compare.
            route2 (dict): The second route to compare.
            
        Returns:
            bool: Whether the routes have the same attributes."""
        return route1['localpref'] == route2['localpref'] \
            and route1['origin'] == route2['origin'] \
            and route1['ASPath'] == route2['ASPath'] \
            and route1['selfOrigin'] == route2['selfOrigin'] \

    def aggregate(self, route1, route2):
        """
        Aggregate two adjacent routes into one. Assumes that the routes are adjacent
        and have the same netmask, next-hop, and other relevant attributes.

        Args:
            route1 (dict): The first route to aggregate.
            route2 (dict): The second route to aggregate.

        Returns:
            dict: A new route that represents the aggregation of route1 and route2.
        """
        # Convert netmask to integer for comparison and calculation
        netmask_int = self.ip_to_int(route1['netmask'])
        
        # Calculate the new netmask by subtracting one from the binary representation's length
        new_netmask_int = (netmask_int << 1) & 0xFFFFFFFF
        new_netmask = self.int_to_ip(new_netmask_int)
        
        # The new network is the lower of the two original networks under the new netmask
        new_network_int = self.ip_to_int(route1['network']) & new_netmask_int
        new_network = self.int_to_ip(new_network_int)

        # Return a new route with the aggregated network and netmask, and the same attributes
        return {
            'network': new_network,
            'netmask': new_netmask,
            'localpref': route1['localpref'],
            'selfOrigin': route1['selfOrigin'],
            'ASPath': route1['ASPath'],
            'origin': route1['origin'],
        }

    def log_message(self, message):
        """
        Helper method for logging messages.
        """
        print(message)

    def shutdown(self):
        """
        Cleanly shut down the router, closing any open connections.
        """
        pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()